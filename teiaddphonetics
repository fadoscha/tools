#!/usr/bin/perl
# This script requires the following:
# Dependencies: libxml, libxslt, and /usr/share/xml/iso-codes/iso_639.xml
# from iso-codecs

use v5.10;
use warnings;
use strict;
use open ':locale';
use Getopt::Long;
use XML::LibXML;
use XML::LibXSLT;
use XML::LibXML::XPathContext;
# an alternative could be: https://metacpan.org/pod/C::DynaLib
use IPC::Open2;

my $verbose = 0;
my $help = 0;
my $infile = 'fd/eng-ita/eng-ita.tei';
my $outfile;
my $inlang;
my $dryrun = 0;
my $espeak_path;

GetOptions("verbose" => \$verbose,
  "infile=s" => \$infile,
  "outfile=s" => \$outfile,
  "inlang=s" => \$inlang,
  "help" => \$help,
  "dry-run" => \$dryrun,
  "espeak-path=s" => \$espeak_path,
  ) or die("Error in command line arguments\n");

if($help)
{
  say <<"EOT";
    $0

    This script adds pronunciation information to the headwords of a TEI file.
    It goes through all <orth> elements and adds a <pron> element after it,
    unless <pron> already exists.

    This script uses 'espeak(-ng) -v <LANG> --ipa -q ok'.  A previous version used the
    espeak API by means of a modified version of Speech::eSpeak, but the
    maintainer of that module is unresponsive. Experiments with the espeak API
    via C::DynaLib (or Python c_types)  were successful, but due to
    cross-platform issues and espeak to espeak-ng API issues not further
    pursuit.

    Espeak is started as a subprocess and connected using stdin/stdout. In this
    line-based mode, espeak reads a line from STDIN and outputs a line on
    STDOUT.  Since espeak doesn't flush stdout, we never get a reply.  To prevent
    this deadlock, we use the 'stdbuf' command, which uses LD_PRELOAD to
    change libc behaviour.  stdbuf is even available on MSYS2.

    Another way to talk to espeak-ng in Python:

	import es2ng
	ipa = esng.g2p ('Hello World!', ipa=2)

    Options:

	--dry-run

		Don't write OUTFILE.

	--espeak-path <FULL-PATH-TO-ESPEAK-BINARY>

		Give full path to espeak(-ng) in case autodetection fails.

	--help

		This help.

	--infile, -i <INFILE>

		Use INFILE as input.

		Example: -i eng-ita.tei

	--inlang, -l <CODE>

		Language of the headwords in INFILE.  The CODE is used to
		select the speaker language of espeak.  If not given,
		the basename of INFILE is assumed to have the form la1-la2.tei,
		as used in FreeDict and is translated to the corresponding
		espeak code.

		Example: -l de

	--outfile, -o <OUTFILE>

		Use OUTFILE for output.  If not given, "INFILE.withpron" is used.

		Example: -o output.tei

	--verbose

		Say what is going on.

EOT
  exit 0;
}

$espeak_path ||= `which espeak-ng`;
$espeak_path ||= `which espeak`;
chomp $espeak_path;

unless(defined $infile) { say "--infile not given"; exit 1 };
unless(-r $infile) { say "$infile not readable"; exit 1 };
$outfile ||= "$infile.withpron";
say "Using espeak from '$espeak_path'" if $verbose;
unless(-x $espeak_path) { say "$espeak_path not executable"; exit 1 };

sub iso639_2T_to_1
{
  my $code_2T = shift;
  my $isofile = '/usr/share/xml/iso-codes/iso_639.xml';
  die "Missing $isofile (In Debian install package iso-codes)!" unless -r $isofile;
  my $isodoc = XML::LibXML->load_xml(location => $isofile);
  my $xpc = XML::LibXML::XPathContext->new($isodoc);
  my $expr = '/iso_639_entries/iso_639_entry/@iso_639_1_code[ ../@iso_639_2T_code=\'' . $code_2T . '\' ]';
  say "Evaluating $expr..." if $verbose>1;
  my $code_1 = $xpc->findvalue($expr);
  say "Translated '$code_2T' to '$code_1'" if $verbose;
  return $code_1;
}

unless(defined $inlang)
{
  unless($infile =~ /(\w{3})-\w{3}\.tei$/)
  {
    say "Could not guess input language from $infile.  Please provide --inlang.";
    exit 3;
  }
  my $in3 = $1;
  $inlang = iso639_2T_to_1($in3);
  if(!defined($inlang) or $inlang eq '')
  {
    say "Failed to find input languge from 3 letter code $in3";
    exit 4
  }
}

say "Using language: ", $inlang if $verbose;
say "espeak version: ", `"$espeak_path" --version` if $verbose;

$SIG{PIPE} = sub
{
   die "Got SIGPIPE: $!";
};

my($chld_out, $chld_in);
# https://github.com/espeak-ng/espeak-ng/pull/536
#, '--fflush-stdout'
my @cmd = ('stdbuf', '-o0', $espeak_path, '--ipa', '-v', $inlang, '-q');
my $pid = open2($chld_out, $chld_in, @cmd);
die "open2 failed: $!" unless defined $pid;
say "espeak has PID $pid" if $verbose;
binmode $chld_in, ':utf8';
binmode $chld_out, ':utf8';

XML::LibXSLT->register_function("urn:espeak", "ipa",
  sub {
    my $inword = shift;
    my $count = kill 0, $pid;
    die "espeak exited" if $count != 1;
    say "Writing to espeak-ng: ", $inword if $verbose;
    say $chld_in $inword;
    say "Will read..." if $verbose;
    my $ipa = <$chld_out>;
    $ipa =~ s/^\s+|\s+$//g;# trim
    chomp($ipa);
    say "Got from espeak-ng: ", $ipa if $verbose;
    return $ipa;
    });
my $sdoc = XML::LibXML->load_xml(string => <<'EOT');
<xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:espeak="urn:espeak"
  xmlns:tei="http://www.tei-c.org/ns/1.0"
  exclude-result-prefixes="tei espeak">

  <xsl:template match="tei:orth[not(boolean(following-sibling::tei:pron))]">
    <xsl:copy>
      <xsl:apply-templates match="@*|node()"/>
    </xsl:copy>
    <pron xmlns="http://www.tei-c.org/ns/1.0"><xsl:value-of select="espeak:ipa(.)"/></pron>
  </xsl:template>

  <xsl:template match="@*|node()">
    <xsl:copy>
      <xsl:apply-templates select="@*|node()"/>
    </xsl:copy>
  </xsl:template>

</xsl:stylesheet>
EOT
my $xslt = XML::LibXSLT->new();
my $stylesheet = $xslt->parse_stylesheet($sdoc);
print "Transforming $infile to $outfile... " if $verbose;
my $results = $stylesheet->transform_file($infile);
$stylesheet->output_file($results, $outfile) unless $dryrun;
close($chld_in);
say "done." if $verbose;

